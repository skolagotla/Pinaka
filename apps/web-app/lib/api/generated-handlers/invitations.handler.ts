/**
 * Generated API Handler for Invitation
 * 
 * ⚠️ DO NOT EDIT THIS FILE MANUALLY
 * This file is auto-generated from the canonical schema registry.
 * Run `npm run generate:api-handlers` to regenerate.
 * 
 * Generated: 2025-11-18T02:40:03.900Z
 */

import { NextApiRequest, NextApiResponse } from 'next';
import { withAuth, UserContext } from '@/lib/middleware/apiMiddleware';
import { InvitationService, InvitationRepository } from '@/lib/domains/invitation';

import { invitationCreateSchema, invitationUpdateSchema, invitationQuerySchema } from '@/lib/schemas';
const { prisma } = require('@/lib/prisma');

/**
 * API Handler for Invitation CRUD operations
 */
async function handler(req: NextApiRequest, res: NextApiResponse, user: UserContext) {
  const repository = new InvitationRepository(prisma);
  const service = new InvitationService(repository);

  try {
    switch (req.method) {
      case 'GET': {
        // List Invitations
        if (!req.query.id) {
          const query = invitationQuerySchema.parse(req.query);
          const result = await service.getInvitations(query, user);
          const items = result.invitations;
          const total = result.total || (Array.isArray(items) ? items.length : 0);
          const page = query.page || 1;
          const limit = query.limit || 50;
          return res.status(200).json({
            success: true,
            data: items,
            pagination: {
              page,
              limit,
              total,
              totalPages: Math.ceil(total / limit),
            },
          });
        }

        // Get Invitation by ID
        const id = req.query.id as string;
        const item = await service.getInvitationById(id, user);
        if (!item) {
          return res.status(404).json({ error: 'Invitation not found' });
        }
        return res.status(200).json({ success: true, data: item });
      }

      case 'POST': {
        const data = invitationCreateSchema.parse(req.body);
        const created = await service.createInvitation(data, user);
        return res.status(201).json({ success: true, data: created });
      }

      case 'PATCH': {
        const id = req.query.id as string;
        if (!id) {
          return res.status(400).json({ error: 'ID is required' });
        }
        const data = invitationUpdateSchema.parse(req.body);
        const updated = await service.updateInvitation(id, data, user);
        return res.status(200).json({ success: true, data: updated });
      }

      case 'DELETE': {
        const id = req.query.id as string;
        if (!id) {
          return res.status(400).json({ error: 'ID is required' });
        }
        await service.deleteInvitation(id, user);
        res.status(204).end();
        return;
      }

      default:
        return res.status(405).json({ error: 'Method not allowed' });
    }
  } catch (error: any) {
    if (error.name === 'ZodError') {
      return res.status(400).json({
        error: 'Validation error',
        details: error.issues,
      });
    }
    console.error(`[Invitation API Handler] Error:`, error);
    return res.status(500).json({
      error: error.message || 'Internal server error',
    });
  }
}

export default withAuth(handler, {
  requireRole: ['landlord', 'pmc', 'admin'],
  allowedMethods: ['GET', 'POST', 'PATCH', 'DELETE'],
});
