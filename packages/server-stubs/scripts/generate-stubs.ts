/**
 * Generate Server Stubs from @pinaka/schema
 * 
 * This generates boilerplate server handler stubs from the schema package
 * Run with: npm run generate:stubs
 */

import * as fs from 'fs';
import * as path from 'path';
import { schemaRegistry } from '@/schema/types/registry';

const OUTPUT_DIR = path.join(__dirname, '../src/generated-stubs');

/**
 * Convert domain key to PascalCase
 */
function toPascalCase(str: string): string {
  return str
    .split('-')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');
}

/**
 * Convert domain key to camelCase
 */
function toCamelCase(str: string): string {
  const parts = str.split('-');
  return parts[0] + parts.slice(1).map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join('');
}

/**
 * Generate server stubs
 */
function generateStubs(): void {
  // Create output directory
  if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, { recursive: true });
  }

  const stubExports: string[] = [];
  const stubImports: string[] = [];

  // Generate stub for each domain
  for (const [domainKey, domainDef] of Object.entries(schemaRegistry)) {
    const domainName = domainDef.domain;
    const pascalDomain = toPascalCase(domainName);
    const camelDomain = toCamelCase(domainKey);

    const stubContent = `/**
 * Generated Server Stub for ${pascalDomain}
 * 
 * ⚠️ DO NOT EDIT THIS FILE MANUALLY
 * This file is auto-generated from @pinaka/schema.
 * Run \`npm run generate:stubs\` to regenerate.
 * 
 * Generated: ${new Date().toISOString()}
 */

import { NextApiRequest, NextApiResponse } from 'next';
import { withAuth, UserContext } from '@/lib/middleware/apiMiddleware';
import { ${pascalDomain}Service, ${pascalDomain}Repository } from '@/lib/domains/${domainName}';
import { 
  ${domainDef.schemas.create ? `${camelDomain}CreateSchema` : 'z'}, 
  ${domainDef.schemas.update ? `${camelDomain}UpdateSchema` : 'z'}, 
  ${domainDef.schemas.query ? `${camelDomain}QuerySchema` : 'z'} 
} from '@pinaka/schema';
import { z } from 'zod';
const { prisma } = require('@/lib/prisma');

/**
 * API Handler for ${pascalDomain} CRUD operations
 */
async function handler(req: NextApiRequest, res: NextApiResponse, user: UserContext) {
  const repository = new ${pascalDomain}Repository(prisma);
  const service = new ${pascalDomain}Service(repository);

  try {
    switch (req.method) {
      case 'GET': {
        // List ${pascalDomain}s
        if (!req.query.id) {
          const query = ${domainDef.schemas.query ? `${camelDomain}QuerySchema` : 'z.object({})'}.parse(req.query);
          const result = await service.list(query, user);
          return res.status(200).json({
            success: true,
            data: result.data,
            pagination: result.pagination,
          });
        }

        // Get ${pascalDomain} by ID
        const id = req.query.id as string;
        const item = await service.getById(id, user);
        if (!item) {
          return res.status(404).json({ error: '${pascalDomain} not found' });
        }
        return res.status(200).json({ success: true, data: item });
      }

      case 'POST': {
        const data = ${domainDef.schemas.create ? `${camelDomain}CreateSchema` : 'z.object({})'}.parse(req.body);
        const created = await service.create(data, user);
        return res.status(201).json({ success: true, data: created });
      }

      case 'PATCH': {
        const id = req.query.id as string;
        if (!id) {
          return res.status(400).json({ error: 'ID is required' });
        }
        const data = ${domainDef.schemas.update ? `${camelDomain}UpdateSchema` : 'z.object({})'}.parse(req.body);
        const updated = await service.update(id, data, user);
        return res.status(200).json({ success: true, data: updated });
      }

      case 'DELETE': {
        const id = req.query.id as string;
        if (!id) {
          return res.status(400).json({ error: 'ID is required' });
        }
        await service.delete(id, user);
        return res.status(204).send();
      }

      default:
        return res.status(405).json({ error: 'Method not allowed' });
    }
  } catch (error: any) {
    if (error.name === 'ZodError') {
      return res.status(400).json({
        error: 'Validation error',
        details: error.errors,
      });
    }
    console.error(\`[${pascalDomain} API Handler] Error:\`, error);
    return res.status(500).json({
      error: error.message || 'Internal server error',
    });
  }
}

export default withAuth(handler, {
  requireRole: ['landlord', 'pmc', 'admin'],
  allowedMethods: ${JSON.stringify(domainDef.methods)},
});
`;

    const stubFileName = `${camelDomain}.stub.ts`;
    const stubFilePath = path.join(OUTPUT_DIR, stubFileName);
    fs.writeFileSync(stubFilePath, stubContent, 'utf-8');

    stubImports.push(`import ${camelDomain}Stub from './generated-stubs/${camelDomain}.stub';`);
    stubExports.push(`  ${camelDomain}: ${camelDomain}Stub,`);
  }

  // Generate index file
  const indexContent = `/**
 * Generated Server Stubs Index
 * 
 * ⚠️ DO NOT EDIT THIS FILE MANUALLY
 * This file is auto-generated from @pinaka/schema.
 * Run \`npm run generate:stubs\` to regenerate.
 * 
 * Generated: ${new Date().toISOString()}
 */

${stubImports.join('\n')}

export const serverStubs = {
${stubExports.join('\n')}
};

export default serverStubs;
`;

  const indexFilePath = path.join(OUTPUT_DIR, 'index.ts');
  fs.writeFileSync(indexFilePath, indexContent, 'utf-8');

  console.log(`✅ Generated server stubs: ${OUTPUT_DIR}`);
  console.log(`   Generated ${Object.keys(schemaRegistry).length} stub files`);
  console.log(`   ⚠️  Note: These are boilerplate templates. Review and customize as needed.`);
}

// Run generation
try {
  generateStubs();
} catch (error) {
  console.error('❌ Error generating server stubs:', error);
  process.exit(1);
}

